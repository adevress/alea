/**
 * Copyright (c) 2021, Adrien Devresse <adev@adev.name>
 *
 * Boost Software License - Version 1.0
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
#ifndef RANDOM_ENGINE_MAPPER_MISC_HPP
#define RANDOM_ENGINE_MAPPER_MISC_HPP




#include <cassert>

#include "../random_derivate.hpp"
#include "../random_engine_mapper.hpp"

namespace alea {

namespace impl {



template <typename Uint>
class abstract_engine {
  public:
    typedef Uint result_type;

    abstract_engine(){};
    virtual ~abstract_engine(){};

    virtual void map_seed() = 0;
    virtual void map_seed(result_type seed) = 0;

    virtual result_type generate() = 0;

    virtual abstract_engine* clone() = 0;

    virtual abstract_engine* derivate(result_type key) const = 0;

  private:
};


template <typename Uint, typename Engine>
class map_engine_intern : public abstract_engine<Uint> {
  public:
    typedef Uint result_type;

    map_engine_intern(const Engine& e) : _e(e) {}

    virtual void map_seed() { _e.seed(); }

    virtual void map_seed(result_type s) { _e.seed(s); }

    virtual result_type generate() { return _e(); }

    virtual abstract_engine<result_type>* clone() { return new map_engine_intern(_e); }

    virtual abstract_engine<result_type>* derivate(result_type key) const {
        Engine derivated_engine = random_engine_derivate(_e, key);
        map_engine_intern<result_type, Engine>* ret = new map_engine_intern<result_type, Engine>(derivated_engine);
        return ret;
    }

  private:
    Engine _e;
};


} // namespace impl

template <typename Uint>
template <typename Engine>
random_engine_mapper<Uint>::random_engine_mapper(Engine&& e)
    : _engine(new impl::map_engine_intern<Uint, Engine>(std::move(e))) {}


template <typename Uint>
random_engine_mapper<Uint>::random_engine_mapper() : _engine() {}

template <typename Uint>
random_engine_mapper<Uint>::random_engine_mapper(random_engine_mapper<Uint>&& other) : _engine(std::move(other._engine)) {}

template <typename Uint>
void random_engine_mapper<Uint>::seed() {
    assert(_engine.get());
    _engine->map_seed();
}

template <typename Uint>
void random_engine_mapper<Uint>::seed(result_type seed) {
    assert(_engine.get());
    _engine->map_seed(seed);
}

template <typename Uint>
typename random_engine_mapper<Uint>::result_type random_engine_mapper<Uint>::operator()() {
    assert(_engine.get());
    return _engine->generate();
}

template <typename Uint>
random_engine_mapper<Uint> random_engine_mapper<Uint>::derivate(result_type key) const {
    assert(_engine.get());
    random_engine_mapper res;
    res._engine.reset(_engine->derivate(key));

    return res;
}




} // namespace alea

#endif // RANDOM_ENGINE_MAPPER_MISC_HPP
