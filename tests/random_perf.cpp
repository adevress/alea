/**
 * Copyright (c) 2016, Adrien Devresse <adrien.devresse@epfl.ch>
 *
 * Boost Software License - Version 1.0
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */


#include <chrono>
#include <random>
#include <iostream>

#include <boost/test/floating_point_comparison.hpp>
#include <alea/random.hpp>


using namespace std::chrono;

typedef system_clock::time_point tp;
typedef system_clock cl;


template<typename Duration>
auto time_in_microseconds(Duration duration){
    return std::chrono::duration_cast<std::chrono::microseconds>(duration).count();
}

std::uint64_t test_random_mersenne_twister(std::uint64_t iter) {

    std::uint64_t res = 0;

    tp t1, t2;

    std::uniform_int_distribution<std::uint64_t> dist;
    std::mt19937 twister_engine;

    t1 = cl::now();

    for (std::uint64_t i = 0; i < iter; ++i) {
        res += dist(twister_engine);
    }


    t2 = cl::now();

    std::cout << "mersenne_twister: " << time_in_microseconds(t2 - t1) << std::endl;
    return res;
}



std::uint64_t test_random_mersenne_twister64(std::uint64_t iter) {

    std::uint64_t res = 0;

    tp t1, t2;

    std::uniform_int_distribution<std::uint64_t> dist;
    std::mt19937_64 twister_engine;

    t1 = cl::now();

    for (std::uint64_t i = 0; i < iter; ++i) {
        res += dist(twister_engine);
    }


    t2 = cl::now();

    std::cout << "mersenne_twister64: " << time_in_microseconds(t2 - t1)<< std::endl;
    return res;
}


std::uint64_t test_random_ranlux(std::uint64_t iter) {

    std::uint64_t res = 0;

    tp t1, t2;

    std::uniform_int_distribution<std::uint64_t> dist;
    std::ranlux24 ranlux_engine;

    t1 = cl::now();

    for (std::uint64_t i = 0; i < iter; ++i) {
        res += dist(ranlux_engine);
    }


    t2 = cl::now();

    std::cout << "ranlux: " << time_in_microseconds(t2 - t1) << std::endl;
    return res;
}


std::uint64_t test_random_minstd_rand(std::uint64_t iter) {



    std::uint64_t res = 0;

    tp t1, t2;

    std::uniform_int_distribution<std::uint64_t> dist;
    std::minstd_rand mstd_engine;

    t1 = cl::now();

    for (std::uint64_t i = 0; i < iter; ++i) {
        res += dist(mstd_engine);
    }


    t2 = cl::now();

    std::cout << "minstd: " << time_in_microseconds(t2 - t1) << std::endl;
    return res;
}


std::uint64_t test_random_threefry4x64(std::uint64_t iter) {

    std::uint64_t res = 0;

    tp t1, t2;

    std::uniform_int_distribution<std::uint64_t> dist;

    alea::counter_engine<alea::threefry4x64> threefry_engine;

    t1 = cl::now();

    for (std::uint64_t i = 0; i < iter; ++i) {
        res += dist(threefry_engine);
    }

    t2 = cl::now();

    std::cout << "threefry4x64: " << time_in_microseconds(t2 - t1) << std::endl;
    return res;
}



std::uint64_t test_random_threefry2x64(std::uint64_t iter) {

    std::uint64_t res = 0;

    tp t1, t2;

    std::uniform_int_distribution<std::uint64_t> dist;

    alea::counter_engine<alea::threefry2x64> threefry_engine;

    t1 = cl::now();

    for (std::uint64_t i = 0; i < iter; ++i) {
        res += dist(threefry_engine);
    }

    t2 = cl::now();

    std::cout << "threefry2x64: " << time_in_microseconds(t2 - t1) << std::endl;
    return res;
}


std::uint64_t test_random_threefry_block_fake(std::uint64_t iter) {

    std::uint64_t res = 0;

    tp t1, t2;

    std::uniform_int_distribution<std::uint64_t> dist;

    alea::counter_engine<alea::threefry4x64> threefry_engine;

    t1 = cl::now();

    const std::uint64_t size_block =
        sizeof(typename alea::counter_engine<alea::threefry4x64>::ctr_type) / sizeof(std::uint64_t);

    for (std::uint64_t i = 0; i < iter; ++i) {
        auto block = threefry_engine.generate_block();
        for (std::uint64_t i = 0; i < size_block; ++i) {
            res += block[0];
        }
    }


    t2 = cl::now();

    std::cout << "threefry block gen: " << time_in_microseconds(t2 - t1) << std::endl;
    return res;
}


int main() {

    const std::uint64_t n_exec = 10000000;
    std::uint64_t junk = 0;

    std::cout << "generation of " << n_exec << " random numbers" << std::endl;

    junk += test_random_mersenne_twister(n_exec);

    junk += test_random_ranlux(n_exec);

    junk += test_random_mersenne_twister64(n_exec);

    junk += test_random_minstd_rand(n_exec);

    junk += test_random_threefry4x64(n_exec);

    junk += test_random_threefry2x64(n_exec);

    junk += test_random_threefry_block_fake(n_exec);


    std::cout << "accumulation: " << junk << std::endl;
}
